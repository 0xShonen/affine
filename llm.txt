Goal
Build a static website that reads Cloudflare R2 via S3 API and displays the contents of affine/index.json, then (optionally) lists/opens the shard files it references.

R2 credentials and addressing
- Account subdomain (host): R2_BUCKET_ID (example: 80f15715bb0b882c9e967c13e677ed7d)
- Bucket name: R2_FOLDER (example: affine)
- Access key: R2_WRITE_ACCESS_KEY_ID
- Secret key: R2_WRITE_SECRET_ACCESS_KEY
- S3 endpoint URL pattern: https://{R2_BUCKET_ID}.r2.cloudflarestorage.com/{R2_FOLDER}/{OBJECT_KEY}
  - Example (index): https://80f15715bb0b882c9e967c13e677ed7d.r2.cloudflarestorage.com/affine/affine/index.json

Object layout and how index is updated
- Bucket: {R2_FOLDER}
- Keys used:
  - INDEX_KEY: affine/index.json
  - RESULT_PREFIX: affine/results/
  - Shards: affine/results/{WINDOW_START_BLOCK}-{HOTKEY}.json
- Update flow (from affine/__init__.py):
  1) Results are written to a shard key under RESULT_PREFIX.
  2) If the shard is new, _update_index() reads current affine/index.json (JSON array of strings) and appends the new shard key, then writes it back.
  3) The index file therefore contains a JSON array of shard keys (strings) relative to the same bucket, e.g. ["affine/results/000000000-HOTKEY.json", ...].
- Reading strategy:
  - Fetch affine/index.json
  - For each key in that array, issue another GET to the same host/bucket path to fetch that JSON array (or JSONL, depending on your downstream use).

Access control and read privileges
- The bucket is private; anonymous GET will fail. You must sign requests using AWS Signature Version 4 (SigV4) with the provided access and secret keys.
- Region: use "auto" for R2.
- Service: "s3".
- For GET requests, set x-amz-content-sha256 to UNSIGNED-PAYLOAD and include x-amz-date.
- Authorization header must be computed from the canonical request using HMAC-SHA256 and the key derivation steps (date -> region -> service -> aws4_request).
- Note: Using write-capable keys in a client-only website exposes them to visitors. This is acceptable only in trusted environments. For production, front a minimal server to generate presigned URLs for read or use a read-only R2 key.

Minimal client-side SigV4 (browser, Web Crypto) to fetch the index
- Construct the endpoint: https://{R2_BUCKET_ID}.r2.cloudflarestorage.com/{R2_FOLDER}/affine/index.json
- Sign a GET request with headers: host, x-amz-date, x-amz-content-sha256=UNSIGNED-PAYLOAD, Authorization.
- Fetch and render the JSON.

Example (JavaScript, browser):
```javascript
const enc = new TextEncoder();

function toHex(bytes) {
  return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

async function sha256Bytes(data) {
  return crypto.subtle.digest('SHA-256', data);
}

async function hmac(keyBytes, dataBytes) {
  const k = await crypto.subtle.importKey('raw', keyBytes, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
  return new Uint8Array(await crypto.subtle.sign('HMAC', k, dataBytes));
}

async function signSigV4({ method, url, region, service, accessKeyId, secretAccessKey, headers = {} }) {
  const u = new URL(url);
  const now = new Date();
  const amz = now.toISOString().replace(/[:-]|\..*/g, '').slice(0, 15) + 'Z'; // YYYYMMDDThhmmssZ
  const date = amz.slice(0, 8);

  const canonicalHeaders = {
    ...Object.fromEntries(Object.entries(headers).map(([k, v]) => [k.toLowerCase(), String(v).trim()])),
    host: u.host,
    'x-amz-content-sha256': 'UNSIGNED-PAYLOAD',
    'x-amz-date': amz,
  };
  const signedHeaders = Object.keys(canonicalHeaders).sort().join(';');
  const headerStr = Object.keys(canonicalHeaders).sort().map(k => `${k}:${canonicalHeaders[k]}\n`).join('');

  const canonicalRequest = [
    method,
    u.pathname,
    u.searchParams.toString(),
    headerStr,
    signedHeaders,
    'UNSIGNED-PAYLOAD',
  ].join('\n');
  const crHash = toHex(new Uint8Array(await sha256Bytes(enc.encode(canonicalRequest))));

  const scope = `${date}/${region}/${service}/aws4_request`;
  const stringToSign = ['AWS4-HMAC-SHA256', amz, scope, crHash].join('\n');

  const kDate = await hmac(enc.encode('AWS4' + secretAccessKey), enc.encode(date));
  const kRegion = await hmac(kDate, enc.encode(region));
  const kService = await hmac(kRegion, enc.encode(service));
  const kSigning = await hmac(kService, enc.encode('aws4_request'));
  const signature = toHex(await hmac(kSigning, enc.encode(stringToSign)));

  const auth = `AWS4-HMAC-SHA256 Credential=${accessKeyId}/${scope}, SignedHeaders=${signedHeaders}, Signature=${signature}`;
  return { headers: { ...canonicalHeaders, Authorization: auth } };
}

async function fetchIndex({ accountId, bucketName, accessKeyId, secretAccessKey }) {
  const url = `https://${accountId}.r2.cloudflarestorage.com/${bucketName}/affine/index.json`;
  const { headers } = await signSigV4({
    method: 'GET', url, region: 'auto', service: 's3', accessKeyId, secretAccessKey,
  });
  const res = await fetch(url, { method: 'GET', headers });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return res.json();
}

// Usage: inject your env at build time or from a safe source
// const data = await fetchIndex({ accountId: R2_BUCKET_ID, bucketName: R2_FOLDER, accessKeyId: R2_WRITE_ACCESS_KEY_ID, secretAccessKey: R2_WRITE_SECRET_ACCESS_KEY });
```

How to display the files listed in the index
- After fetching affine/index.json (array of shard keys as strings), for each key K:
  - Build URL: https://{R2_BUCKET_ID}.r2.cloudflarestorage.com/{R2_FOLDER}/{K}
  - Sign a GET request as above and fetch the shard JSON.
  - Render entries, or provide links that trigger signed fetch-and-download on click.

Important implementation notes
- Use x-amz-content-sha256=UNSIGNED-PAYLOAD for GET; do not include a request body in canonical request.
- Region must be "auto" for Cloudflare R2 when using SigV4.
- Service is always "s3".
- Required headers in the canonical request: host, x-amz-date, x-amz-content-sha256 (and any others you choose to include). signedHeaders must exactly match the set used.
- Time skew: x-amz-date should be current UTC; excessive skew can cause auth failures.

Security considerations
- Client-side embedding of access and secret keys gives anyone with page access the ability to make signed S3 requests. This key appears to be write-capable in the current configuration. Prefer one of:
  - Issue short-lived presigned URLs from a small server and keep secrets server-side; or
  - Create an R2 read-only access key; or
  - Restrict exposure to trusted/internal environments.

Summary
- Endpoint: https://{R2_BUCKET_ID}.r2.cloudflarestorage.com/{R2_FOLDER}/affine/index.json
- index.json content: JSON array of shard object keys under the same bucket.
- Auth: SigV4 (region=auto, service=s3, signed headers include host, x-amz-date, x-amz-content-sha256=UNSIGNED-PAYLOAD).
- To display files: fetch index, then fetch each listed key with the same signing flow. 